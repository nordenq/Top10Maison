---
import { CSP_NONCE } from "../utils/csp";

const { open = false, title = "Product details", verdict = "", fallbackUrl } = Astro.props as {
  open?: boolean;
  title?: string;
  verdict?: string;
  fallbackUrl?: string;
};

const drawerState = open ? "open" : "closed";
---

<div
  class="fixed inset-0 z-50 pointer-events-none data-[state=open]:pointer-events-auto"
  aria-hidden={open ? "false" : "true"}
  inert={open ? undefined : true}
  data-state={drawerState}
  data-product-drawer
  data-drawer-fallback={fallbackUrl}
>
  <div
    class="absolute inset-0 bg-ink/60 opacity-0 transition-opacity data-[state=open]:opacity-100"
    data-drawer-overlay
    data-state={drawerState}
  ></div>
  <aside
    class="absolute right-0 top-0 flex h-full w-full max-w-2xl translate-x-full flex-col bg-white shadow-xl transition-transform data-[state=open]:translate-x-0"
    role="dialog"
    aria-modal="true"
    aria-labelledby="drawer-title"
    data-drawer-panel
    data-state={drawerState}
  >
    <div class="flex items-start justify-between gap-4 border-b border-border px-6 py-4">
      <div>
        <h2 id="drawer-title" class="text-lg font-semibold text-ink">{title}</h2>
        <p id="drawer-verdict" class="mt-1 text-sm text-ink/70">{verdict}</p>
      </div>
      <button class="btn-ghost text-sm" type="button" data-drawer-close>Close</button>
    </div>
    <div class="flex-1 overflow-y-auto px-6 py-6" data-drawer-content>
      <slot>
        <p class="text-sm text-ink/70">Loading…</p>
      </slot>
    </div>
  </aside>
</div>

<script type="module" nonce={CSP_NONCE} is:inline>
  const drawerRoot = document.querySelector("[data-product-drawer]");
  if (drawerRoot) {
    const panel = drawerRoot.querySelector("[data-drawer-panel]");
    const overlay = drawerRoot.querySelector("[data-drawer-overlay]");
    const closeButton = drawerRoot.querySelector("[data-drawer-close]");
    const content = drawerRoot.querySelector("[data-drawer-content]");
    const title = drawerRoot.querySelector("#drawer-title");
    const verdict = drawerRoot.querySelector("#drawer-verdict");
    const fallbackUrl = drawerRoot.dataset.drawerFallback || null;
    const linkSelector = "a[data-drawer-link]";
    let isOpen = drawerRoot.dataset.state === "open";
    let activeUrl = null;
    let fetchController = null;
    let trustedHtmlPolicy = null;
    let lastActiveElement = null;

    const getTrustedHtml = (value) => {
      if (!window.trustedTypes) return value;
      if (!trustedHtmlPolicy) {
        try {
          trustedHtmlPolicy = window.trustedTypes.createPolicy("default", {
            createHTML: (input) => input
          });
        } catch (error) {
          try {
            trustedHtmlPolicy = window.trustedTypes.createPolicy("top10maison-drawer", {
              createHTML: (input) => input
            });
          } catch (innerError) {
            trustedHtmlPolicy = null;
          }
        }
      }
      return trustedHtmlPolicy ? trustedHtmlPolicy.createHTML(value) : value;
    };

    const setOpenState = (open) => {
      isOpen = open;
      drawerRoot.dataset.state = open ? "open" : "closed";
      overlay.dataset.state = open ? "open" : "closed";
      panel.dataset.state = open ? "open" : "closed";
      if (open) {
        drawerRoot.inert = false;
        drawerRoot.setAttribute("aria-hidden", "false");
        document.documentElement.style.overflow = "hidden";
        document.body.style.overflow = "hidden";
        closeButton?.focus();
      } else {
        if (lastActiveElement && typeof lastActiveElement.focus === "function") {
          lastActiveElement.focus();
        }
        drawerRoot.inert = true;
        drawerRoot.setAttribute("aria-hidden", "true");
        document.documentElement.style.overflow = "";
        document.body.style.overflow = "";
        lastActiveElement = null;
      }
    };

    const stripScripts = (root) => {
      root.querySelectorAll("script").forEach((script) => script.remove());
    };

    const replaceDrawerContent = (source) => {
      stripScripts(source);
      const nodes = Array.from(source.childNodes).map((node) => document.importNode(node, true));
      content.replaceChildren(...nodes);
    };

    const parseDrawerHtml = (html) => {
      const trustedHtml = getTrustedHtml(html);
      const doc = new DOMParser().parseFromString(trustedHtml, "text/html");
      const fragment = doc.querySelector("[data-drawer-fragment]");
      const fragmentTitle = fragment?.querySelector("[data-drawer-title]");
      const fragmentVerdict = fragment?.querySelector("[data-drawer-verdict]");
      if (title && fragmentTitle?.textContent) {
        title.textContent = fragmentTitle.textContent.trim();
      }
      if (verdict && fragmentVerdict?.textContent) {
        verdict.textContent = fragmentVerdict.textContent.trim();
      }
      if (fragment) {
        replaceDrawerContent(fragment);
        return;
      }
      replaceDrawerContent(doc.body);
    };

    const loadDrawerContent = async (url) => {
      if (!content) return;
      if (fetchController) fetchController.abort();
      fetchController = new AbortController();
      const loading = document.createElement("p");
      loading.className = "text-sm text-ink/70";
      loading.textContent = "Loading…";
      content.replaceChildren(loading);
      const fetchUrl = new URL(url, window.location.origin);
      fetchUrl.searchParams.set("drawer", "1");
      const response = await fetch(fetchUrl.toString(), { signal: fetchController.signal });
      if (!response.ok) throw new Error("Drawer fetch failed.");
      const html = await response.text();
      parseDrawerHtml(html);
    };

    const openDrawer = async (url, { push = true } = {}) => {
      if (!url) return;
      activeUrl = url;
      lastActiveElement = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      setOpenState(true);
      if (push) {
        history.pushState({ drawerOpen: true, url }, "", url);
      }
      try {
        await loadDrawerContent(url);
      } catch (error) {
        if (!(error instanceof DOMException && error.name === "AbortError")) {
          window.location.assign(url);
        }
      }
    };

    const autoOpenFromQuery = () => {
      const params = new URLSearchParams(window.location.search);
      const drawerProduct = params.get("drawerProduct");
      if (!drawerProduct) return;
      const productUrl = new URL(`/product/${drawerProduct}/`, window.location.origin).toString();
      openDrawer(productUrl, { push: false });
    };

    const closeDrawer = ({ fromPopstate = false } = {}) => {
      if (!isOpen) return;
      setOpenState(false);
      activeUrl = null;
      if (!fromPopstate && history.state?.drawerOpen) {
        history.back();
        return;
      }
      if (!fromPopstate && fallbackUrl) {
        window.location.assign(fallbackUrl);
      }
    };

    document.addEventListener("click", (event) => {
      const target = event.target;
      const element = target instanceof Element ? target : target?.parentElement;
      if (!element) return;
      const link = element.closest(linkSelector);
      if (!link) return;
      if (event.defaultPrevented || event.button !== 0) return;
      if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
      event.preventDefault();
      openDrawer(link.href);
    });

    overlay.addEventListener("click", () => closeDrawer());
    drawerRoot.addEventListener("click", (event) => {
      const target = event.target;
      if (!(target instanceof Element)) return;
      const closeTarget = target.closest("[data-drawer-close]");
      if (!closeTarget) return;
      closeDrawer();
    });

    document.addEventListener("keydown", (event) => {
      if (!isOpen) return;
      if (event.key === "Escape") {
        event.preventDefault();
        closeDrawer();
      }
    });

    window.addEventListener("popstate", (event) => {
      if (event.state?.drawerOpen && event.state.url) {
        if (event.state.url !== activeUrl) {
          openDrawer(event.state.url, { push: false });
        } else {
          setOpenState(true);
        }
        return;
      }
      if (isOpen && activeUrl && window.location.href === activeUrl) {
        return;
      }
      closeDrawer({ fromPopstate: true });
    });

    if (isOpen) {
      setOpenState(true);
    }

    autoOpenFromQuery();
  }
</script>
